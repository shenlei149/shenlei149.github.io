[110题链接](https://projecteuler.net/problem=110 "Problem 110 - Project Euler")

正整数方程
$$\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$$
如果 $n=1260$，那么有 113 个不同的解，这是不同解的数量超过 100 的最小的 $n$ 值。

求不同解的数量超过四百万的 $n$ 的最小值。

$x$ 和 $y$ 必须大于 $n$，否则 $1/x$ 或 $1/y$ 就比 $1/n$ 大了。所以不妨令 $x=n+a,y=n+b$，其中 $a,b$ 也都是整数。代入原式，我们可以得到 $n^2=ab$。所以原方程就变成了 $n^2$ 有多少种方式分解成两数之积。

$n$ 可以写作
$$p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m}$$
$n^2$ 可以写作
$$p_1^{2k_1}p_2^{2k_2}\cdots p_m^{2k_m}$$
因数的个数是$(2k_1+1)(2k_m+1)\cdots(2k_m+1)$，那么解的个数就是因数个数加一除以二。

我们可以找到一个数，满足题意，但不一定最小。

假设 $k_i$ 取值都是1，那么前十五个质数 $(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47)$ 乘积组成的 $n$ 就有超过四百万个解，因为 $(3^{15}+1)/2=7,174,454$。

能不能让这个数再小一点呢？

去掉尾部的一个质数，因数会小三倍，那么前面某个质数对应的 $k$ 从1 到 4，那么指数从 3 到 9，刚好弥补三倍，2 的三次方是 8，3 的三次方是 27，比 43 和 47 小，所以可以去掉，然后 $k_1$ 和$k_2$ 升到4。

上面我们推测的数对应的因子比四百万大很多，能不能去掉 41 呢？5 和 7 对应的 $k$ 从 1 到 2，那么指数涨了 5/3 倍，两个数就是 25/9 倍，再除以三，是 25/27 倍，得到的因数还是远远大于四百万的。

综上，我们只需要前十二个质数即可。对应的 $k$ 的取值分别是 $\{4,4,2,2,1,1,1,1,1,1,1,1\}$。这些值的上限是多少呢？

17 对应的 $k$ 值上限就是 1。如果是2 ，那么相比 1，因数个数增长了 5/3 倍，那么 2 从 4 到 6，3 从 4 到 5，增长 143/81，比 5/3 要大，但是其乘积是 12，比 17 小。17 之后的也上限也只能是1。

其他数字的上限怎么确定呢？我们用 5 做例子。假设对应的 $k$ 最大是 5，那么考虑把它减到 2，因数少了 11/5 倍，我们增加一个质数比如 41，能增加三倍的因数，同时 41 比 125 小很多。所以 5 太宽松了，最大值取 4 即可。

经过一系列的分析，可以得出对应的最大值分别是 $\{ 9, 5, 4, 2, 2, 2, 1, 1, 1, 1, 1, 1 \}$。

下面是代码，从取值为 0 开始，一直循环到最大值，然后看因数个数是否大于四百万，然后在所有满足题意的数字中选择最小的。
``` csharp
private readonly int MAX = 4_000_000;
private readonly int[] Primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
private readonly int[] MaxPower = [9, 5, 4, 2, 2, 2, 1, 1, 1, 1, 1, 1];

private BigInteger min = long.MaxValue;

private void Check(int[] power, int index)
{
    if (index == power.Length)
    {
        int count = 1;
        foreach (var item in power)
        {
            count *= (1 + item * 2);
        }
        count++;
        count /= 2;

        if (count > MAX)
        {
            var n = Primes.Zip(power, (i, j) => (long)Math.Pow(i, j))
                .Select(l => (BigInteger)l).Aggregate(BigInteger.Multiply);
            if (n < min)
            {
                min = n;
            }
        }
    }
    else
    {
        for (int i = 0; i <= MaxPower[index]; i++)
        {
            var copy = power.ToArray();
            copy[index] = i;
            Check(copy, index + 1);
        }
    }
}
```
``` csharp
Check([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0);
```
